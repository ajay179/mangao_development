import { Node, Element, DataNode, NodeWithChildren, Document } from "./node";
export * from "./node";
export interface DomHandlerOptions {
    /**
     * Add a `startIndex` property to nodes.
     * When the parser is used in a non-streaming fashion, `startIndex` is an integer
     * indicating the position of the start of the node in the document.
     *
     * @default false
     */
    withStartIndices?: boolean;
    /**
     * Add an `endIndex` property to nodes.
     * When the parser is used in a non-streaming fashion, `endIndex` is an integer
     * indicating the position of the end of the node in the document.
     *
     * @default false
     */
    withEndIndices?: boolean;
    /**
     * Replace all whitespace with single spaces.
     *
     * **Note:** Enabling this might break your markup.
     *
     * @default false
     * @deprecated
     */
    normalizeWhitespace?: boolean;
    /**
     * Treat the markup as XML.
     *
     * @default false
     */
    xmlMode?: boolean;
}
interface ParserInterface {
    startIndex: number | null;
    endIndex: number | null;
}
declare type Callback = (error: Error | null, dom: Node[]) => void;
declare type ElementCallback = (element: Element) => void;
export declare class DomHandler {
    /** The elements of the DOM */
    dom: Node[];
    /** The root element for the DOM */
    root: Document;
    /** Called once parsing has completed. */
    private readonly callback;
    /** Settings for the handler. */
    private readonly options;
    /** Callback whenever a tag is closed. */
    private readonly elementCB;
    /** Indicated whether parsing has been completed. */
    private done;
    /** Stack of open tags. */
    protected tagStack: NodeWithChildren[];
    /** A data node that is still being written to. */
    protected lastNode: DataNode | null;
    /** Reference to the parser i